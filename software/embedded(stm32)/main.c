/* USER CODE BEGIN Header */
/**
 * Script Name: main.c (Embedded Firmware)
 * Description:
 *   Core firmware for the STM32H7 camera module. Manages the OV5640 image
 * sensor via I2C, captures images using DCMI and DMA, and streams data to a
 * host PC over USB CDC. Supports live preview mode with handshaking and
 * registry updates.
 *
 */
/* USER CODE END Header */

// all code written by me with minimal AI assistance, comments added using AI
// and verified by me

/* Includes ------------------------------------------------------------------*/
#include "main.h"
#include "usb_device.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
/* Includes ------------------------------------------------------------------*/
#include "main.h"                 // Cube-generated base header
#include "stm32h7xx.h"            // CMSIS core + device defines
#include "stm32h7xx_hal.h"        // Core HAL
#include "stm32h7xx_hal_cortex.h" // Core functions (NVIC, SysTick, etc.)
#include "stm32h7xx_hal_dcmi.h"   // DCMI camera interface
#include "stm32h7xx_hal_dma.h"    // DMA API
#include "stm32h7xx_hal_gpio.h"   // GPIO HAL (if not included in main.h)
#include "stm32h7xx_hal_i2c.h"    // I2C HAL
#include "stm32h7xx_hal_rcc.h"
#include "stm32h7xx_hal_rcc_ex.h" // <-- defines __HAL_RCC_DMAMUX1_CLK_ENABLE
#include "stm32h7xx_ll_bus.h"     // fallback LL clock enables

#include "usbd_cdc_if.h"
#include <stdbool.h> // for bool, true, false
#include <stdbool.h>
#include <stdint.h> // for uint8_t, uint32_t, etc.
#include <stdio.h>  // for printf, setvbuf
#include <string.h> // for memset, memcpy (optional)

/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */
/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */
/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */
/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/

DCMI_HandleTypeDef hdcmi;
DMA_HandleTypeDef hdma_dcmi;

I2C_HandleTypeDef hi2c1;

/* USER CODE BEGIN PV */
#define OV5640_ADDR_8BIT (0x3C << 1) // OV5640 I2C address
#define REG_CHIP_ID_HIGH                                                       \
  0x300A // test variables for testing conneciton to camera
#define REG_CHIP_ID_LOW                                                        \
  0x300B // test variables for testing conneciton to
         // camera

#define MAX_REGISTRY_SIZE 256 // Reserved amount of memory for I2C writes map

// I2C adress changes map
typedef struct {
  uint16_t reg_addr;
  uint8_t val;
} OV5640_Reg_t;

// create I2C hash map
OV5640_Reg_t OV5640_Registry[MAX_REGISTRY_SIZE];
uint16_t OV5640_Registry_Count = 0;

// Helper to keep track if we have loaded defaults yet
bool defaults_loaded = false;
/* USER CODE END PV */

/* Private function prototypes generated by STM32IDE
 * -----------------------------------------------*/
void SystemClock_Config(void);
static void MPU_Config(void);
static void MX_GPIO_Init(void);
static void MX_DMA_Init(void);
static void MX_I2C1_Init(void);
static void MX_DCMI_Init(void);
void Registry_Set(uint16_t reg, uint8_t val);
void Registry_LoadDefaults(void);
void Registry_ApplyAll(void);
void Parse_USB_Command(char *cmd);
void Camera_LiveLoop(void);
/* USER CODE BEGIN PFP */

static uint32_t rx_index = 0;

DCMI_HandleTypeDef hdcmi; // global

uint8_t CDC_Transmit_HS(uint8_t *Buf, uint16_t Len);

#define CAM_RST_Port GPIOD
#define CAM_RST_Pin GPIO_PIN_0

#define CAM_PWDN_Port GPIOD
#define CAM_PWDN_Pin GPIO_PIN_1

#define N 1

#define W 320
#define H 240
#define BPP 2
#define FRAME_BYTES (W * H * BPP)
#define CHUNK_SIZE 4096 // 4KB chunks are safe for the HAL

/* ---- Use D1 AXI SRAM, not SDRAM ---- */
#undef FB_BASE_ADDR
#define FB_BASE_ADDR 0x30000000U // D2 SRAM1
uint8_t *const framebuf = (uint8_t *)FB_BASE_ADDR;
#define FB_BASE ((uint8_t *)FB_BASE_ADDR)

/* Optional: keep a 256 KB non-cacheable MPU window at 0x24000000 */
#define DMA_WIN_BASE 0x24000000U
#define DMA_WIN_SIZE MPU_REGION_SIZE_256KB

static inline void swo_put(uint8_t b) { ITM_SendChar(b); }

uint32_t words = FRAME_BYTES / 4;

volatile bool dcmi_stop_req = false;

volatile uint8_t camera_frame_ready = 0;
volatile uint8_t camera_error_flag = 0;

extern volatile uint8_t trigger_flag;
volatile uint8_t trigger_flag = 0;

volatile uint8_t usb_rx_buffer[64]; // Buffer to store incoming data
volatile uint8_t usb_rx_flag = 0; // Flag: 1 = New data arrived, 0 = No new data

static void MPU_Config(void);
static void MX_FMC_Init(void);
static void CameraI2Cinit(void);
static void Camerainit(void);
/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */

/**
 * @brief Initializes the Serial Wire Output (SWO) for ITM debugging.
 * @param swo_hz The desired frequency for the trace clock.
 */
static void SWO_Init(uint32_t swo_hz) {
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk; // enable trace unit
  DBGMCU->CR |= (1U << 5); // TRACE_IOEN -> route TRACESWO

  // Force PB3 = TRACESWO (AF0)
  __HAL_RCC_GPIOB_CLK_ENABLE();
  GPIO_InitTypeDef GI = {0};
  GI.Pin = GPIO_PIN_3;
  GI.Mode = GPIO_MODE_AF_PP;
  GI.Pull = GPIO_NOPULL;
  GI.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
  GI.Alternate = 0; // AF0 = JTDO/TRACESWO
  HAL_GPIO_Init(GPIOB, &GI);

  TPI->SPPR = 2; // NRZ/Async
  TPI->ACPR =
      (SystemCoreClock / swo_hz) - 1; // e.g. 99 for 2 MHz @ 200 MHz core
  TPI->FFCR = 0x100;

  ITM->LAR = 0xC5ACCE55;         // unlock (H7)
  ITM->TCR = ITM_TCR_ITMENA_Msk; // enable ITM
  ITM->TER = (1U << 0);          // port 0 on
}

int _write(int file, char *ptr, int len) {
  (void)file;
  for (int i = 0; i < len; i++)
    ITM_SendChar((uint32_t)ptr[i]);
  return len;
}

/**
 * @brief Performs a full hardware power-up and reset sequence for the OV5640
 * sensor.
 *
 * Controls the PWDN and RESET pins to ensure the sensor enters a clean state
 * according to the OmniVision power-on timing requirements.
 */
static void CamhardwareReset(void) {
  printf("[PWR] Proper power sequence start...\n");

  // Ensure sensor is in power-down before reset pulse
  HAL_GPIO_WritePin(CAM_PWDN_Port, CAM_PWDN_Pin,
                    GPIO_PIN_SET); // PWDN = 1 → sleep
  HAL_Delay(10);

  // Assert reset
  HAL_GPIO_WritePin(CAM_RST_Port, CAM_RST_Pin,
                    GPIO_PIN_RESET); // RESET = 0 → hold in reset
  HAL_Delay(10);

  // Power up
  HAL_GPIO_WritePin(CAM_PWDN_Port, CAM_PWDN_Pin,
                    GPIO_PIN_RESET); // PWDN = 0 → active mode
  HAL_Delay(5);

  // Release from reset
  HAL_GPIO_WritePin(CAM_RST_Port, CAM_RST_Pin, GPIO_PIN_SET); // RESET = 1 → run
  HAL_Delay(20);

  printf("[PWR] OV5640 released from reset & power-down.\n");
}

/**
 * @brief Writes an 8-bit value to a 16-bit register address on the OV5640.
 * @param reg 16-bit register address.
 * @param val 8-bit value to write.
 * @return HAL status.
 */
static HAL_StatusTypeDef cam_write_u8(uint16_t reg, uint8_t val) {
  uint8_t buf[3] = {(uint8_t)(reg >> 8), (uint8_t)reg, val};
  HAL_StatusTypeDef st =
      HAL_I2C_Master_Transmit(&hi2c1, OV5640_ADDR_8BIT, buf, 3, 100);
  printf("[I2C] W 0x%04X <- 0x%02X %s\r\n", reg, val,
         (st == HAL_OK) ? "OK" : "ERR");
  return st;
}

/**
 * @brief Reads an 8-bit value from a 16-bit register address on the OV5640.
 * @param reg 16-bit register address.
 * @param val Pointer to store the retrieved 8-bit value.
 * @return HAL status.
 */
static HAL_StatusTypeDef cam_read_u8(uint16_t reg, uint8_t *val) {
  uint8_t idx[2] = {(uint8_t)(reg >> 8), (uint8_t)reg};
  HAL_StatusTypeDef st;
  st = HAL_I2C_Master_Transmit(&hi2c1, OV5640_ADDR_8BIT, idx, 2, 100);
  if (st != HAL_OK) {
    printf("[I2C] W(reg) 0x%04X ERR\r\n", reg);
    return st;
  }
  st = HAL_I2C_Master_Receive(&hi2c1, OV5640_ADDR_8BIT, val, 1, 100);
  printf("[I2C] R 0x%04X -> 0x%02X %s\r\n", reg, *val,
         (st == HAL_OK) ? "OK" : "ERR");
  return st;
}

static inline void dcache_invalidate_fb(void) {
  uintptr_t a = ((uintptr_t)framebuf) & ~31u;
  size_t n = ((FRAME_BYTES + 31u) & ~31u) + 32u;
  SCB_InvalidateDCache_by_Addr((void *)a, n);
}

/**
 * @brief High-level live preview manager with host handshaking.
 *
 * Continuously captures frames and transmits them over USB. After each frame,
 * it waits for an acknowledgment ('A') or a stop command ('X') from the PC.
 * Includes periodic hardware resets to maintain sensor stability.
 */
void Camera_LiveLoop(void) {
  printf("--- ENTERING LIVE MODE (HANDSHAKE) ---\n");

  bool running = true;
  uint32_t frame_counter = 0; // 1. Initialize Frame Counter

  while (running) {
    // 2. CHECK RESET CONDITION (Every 10 frames)
    // We skip 0 so we don't reset immediately upon entering the mode.
    if (frame_counter > 0 && (frame_counter % 150 == 0)) {
      printf("Live Mode: %lu frames reached. Performing Periodic Reset...\n",
             (unsigned long)frame_counter);

      // Perform the full hardware/software reset sequence
      // This function (defined in USER CODE BEGIN 4) re-initializes DCMI,
      // I2C, and GPIOs
      Camera_Hard_Reset();

      // Note: Camera_Hard_Reset includes a delay (usually 1s) for sensor
      // stabilization.
    }

    // 3. CAPTURE
    Camera_CaptureOneFrame();

    // 4. CHECK FOR CAPTURE ERRORS
    if (camera_error_flag) {
      printf("Live Mode: Capture Error. Retrying...\n");
      HAL_Delay(10);
      continue;
    }

    // 5. SEND FRAME
    DumpFullFrame_USB();

    // 6. WAIT FOR CONFIRMATION (Handshake) with TIMEOUT
    usb_rx_flag = 0;
    bool waiting_for_ack = true;

    // Record the time immediately after sending
    uint32_t wait_start = HAL_GetTick();

    while (waiting_for_ack) {
      // --- TIMEOUT CHECK ---
      if ((HAL_GetTick() - wait_start) > 1000) {
        printf("Live Mode: TIMEOUT (No ACK for 1s). Exiting.\n");
        waiting_for_ack = false;
        running = false; // Stop the outer loop
        break;
      }

      // --- USB CHECK ---
      if (usb_rx_flag == 1) {
        char resp = (char)usb_rx_buffer[0];
        usb_rx_flag = 0;

        if (resp == 'A' || resp == 'a') {
          // ACK received -> Capture next frame
          waiting_for_ack = false;
        } else if (resp == 'X' || resp == 'x') {
          // STOP received -> Exit
          printf("Live Mode: Stop Received.\n");
          waiting_for_ack = false;
          running = false;
        }
      }
    }

    // 7. Increment counter only after a successful cycle
    if (running) {
      frame_counter++;
    }
  }

  printf("--- EXITING LIVE MODE ---\n");
}

/**
 * @brief Updates or adds a register value in the local OV5640 registry.
 *
 * This registry acts as a volatile cache of sensor settings, allowing the
 * firmware to re-apply specific configurations (like exposure or gain) after a
 * reset.
 *
 * @param reg 16-bit register address.
 * @param val 8-bit value.
 */
void Registry_Set(uint16_t reg, uint8_t val) {
  // 1. Search if register already exists (Linear search is fast enough for
  // <500 items)
  for (int i = 0; i < OV5640_Registry_Count; i++) {
    if (OV5640_Registry[i].reg_addr == reg) {
      // Found it! Update the value.
      OV5640_Registry[i].val = val;
      // printf("[REG] Updated 0x%04X to 0x%02X\n", reg, val);
      return;
    }
  }

  // 2. If not found, append to the end
  if (OV5640_Registry_Count < MAX_REGISTRY_SIZE) {
    OV5640_Registry[OV5640_Registry_Count].reg_addr = reg;
    OV5640_Registry[OV5640_Registry_Count].val = val;
    OV5640_Registry_Count++;
    // printf("[REG] Added 0x%04X = 0x%02X\n", reg, val);
  } else {
    printf("[REG] Error: Registry Full!\n");
  }
}

/**
 * @brief Iterates through the local registry and writes every entry to the
 * sensor.
 */
void Registry_ApplyAll(void) {
  printf("[REG] Applying %d registers...\n", OV5640_Registry_Count);
  for (int i = 0; i < OV5640_Registry_Count; i++) {
    cam_write_u8(OV5640_Registry[i].reg_addr, OV5640_Registry[i].val);
  }
  printf("[REG] Apply Complete.\n");
}

/**
 * @brief Loads the hardcoded default camera configuration into the local
 * registry.
 *
 * This includes PLL settings, windowing, output format (YUYV), and ISP tunings.
 */
void Registry_LoadDefaults(void) {
  // Clear existing
  OV5640_Registry_Count = 0;

  // --- SYSTEM & IO PAD CONTROL ---
  Registry_Set(0x3016, 0x00); // System Reset 02 (Not explicitly documented as
                              // 0x3016 likely Reserved/Reset related)
  Registry_Set(
      0x3017,
      0x7F); // IO Control: Pad Output Dir/Enable (PCLK, HREF, VSYNC, etc.)
  Registry_Set(0x3018, 0xFC); // IO Control: Pad Output Dir/Enable (D[9:0])
  Registry_Set(0x3019, 0x00); // Reserved / Internal Use
  Registry_Set(0x301A, 0x00); // Reserved / Internal Use
  Registry_Set(0x301B, 0x00); // Reserved / Internal Use
  Registry_Set(0x301C, 0x00); // Reserved / Internal Use
  Registry_Set(0x301D, 0x00); // Reserved / Internal Use
  Registry_Set(0x301E, 0x00); // Reserved / Internal Use
  Registry_Set(0x302C, 0xC2); // IO Pad Drive Strength (Misc Control)

  // --- PLL (System Clocks) ---
  Registry_Set(
      0x3034,
      0x18); // SC PLL CTRL0: MIPI bit mode (0x8=8bit, 0xA=10bit) / Charge Pump
  Registry_Set(0x3036, 0x69); // SC PLL CTRL2: PLL Multiplier (0x69 = 105)
  Registry_Set(0x3037, 0x13); // SC PLL CTRL3: PLL Root Divider / Pre-divider
  Registry_Set(0x3039, 0x00); // SC PLL CTRL5: PLL Bypass (0=Enable PLL)
  Registry_Set(0x3103, 0x03); // SCCB Control: System Clock (Bit 1=1 -> Use PLL)
  Registry_Set(0x303A, 0x00); // SC PLL CTRL 6 (Likely internal PLL fine tuning)
  Registry_Set(0x303B, 0x19); // SC PLL CTRL 7 (Likely internal PLL fine tuning)
  Registry_Set(0x303C, 0x11); // SC PLL CTRL 8 (Likely internal PLL fine tuning)
  Registry_Set(0x303D, 0x30); // SC PLL CTRL 9 (Likely internal PLL fine tuning)

  // --- WINDOWING & TIMING ---
  Registry_Set(0x3800, 0x00); // TIMING HS: X Address Start High Byte
  Registry_Set(0x3801, 0x01); // TIMING HS: X Address Start Low Byte
  Registry_Set(0x3802, 0x00); // TIMING VS: Y Address Start High Byte
  Registry_Set(0x3803, 0x00); // TIMING VS: Y Address Start Low Byte (Start Y=0)
  Registry_Set(0x3804, 0x0A); // TIMING HW: X Address End High Byte
  Registry_Set(0x3805, 0x3F); // TIMING HW: X Address End Low Byte (End X=2623)
  Registry_Set(0x3806, 0x07); // TIMING VH: Y Address End High Byte
  Registry_Set(0x3807, 0x9B); // TIMING VH: Y Address End Low Byte (End Y=1947)
  Registry_Set(0x3808, 0x01); // TIMING DVPHO: Output Width High Byte (320)
  Registry_Set(0x3809, 0x40); // TIMING DVPHO: Output Width Low Byte
  Registry_Set(0x380A, 0x00); // TIMING DVPVO: Output Height High Byte (240)
  Registry_Set(0x380B, 0xF0); // TIMING DVPVO: Output Height Low Byte
  Registry_Set(0x380C, 0x07); // TIMING HTS: Total Horizontal Size High Byte
  Registry_Set(0x380D, 0x68); // TIMING HTS: Total Horizontal Size Low Byte
  Registry_Set(0x380E, 0x03); // TIMING VTS: Total Vertical Size High Byte
  Registry_Set(0x380F, 0xD8); // TIMING VTS: Total Vertical Size Low Byte
  Registry_Set(0x3810, 0x00); // TIMING HOFFSET: ISP Horizontal Offset High Byte
  Registry_Set(
      0x3811,
      0x10); // TIMING HOFFSET: ISP Horizontal Offset Low Byte (16 pixels)
  Registry_Set(0x3812, 0x00); // TIMING VOFFSET: ISP Vertical Offset High Byte
  Registry_Set(0x3813,
               0x06); // TIMING VOFFSET: ISP Vertical Offset Low Byte (6 lines)
  Registry_Set(0x3814,
               0x31); // TIMING X INC: Horizontal Subsample (Odd/Even increment)
  Registry_Set(0x3815,
               0x31); // TIMING Y INC: Vertical Subsample (Odd/Even increment)
  Registry_Set(0x3816, 0x00); // TIMING VSYNC DELAY (Low)
  Registry_Set(0x3817, 0x00); // TIMING VSYNC DELAY (High)
  Registry_Set(0x3818, 0x00); // TIMING HSYNC DELAY (Low)
  Registry_Set(0x3819, 0x00); // TIMING HSYNC DELAY (High)
  Registry_Set(0x3820,
               0x41); // TIMING TC REG20: Vertical Flip Enable (Bit 1=0, Bit
                      // 2=1?? Check logic, usually Bit 1/2 control flips)
  Registry_Set(0x3821,
               0x07); // TIMING TC REG21: ISP Mirror (Bit 2), Sensor Mirror (Bit
                      // 1), Horizontal Binning (Bit 0) - All ON (0x07) or OFF
                      // depending on exact bit meaning here.

  // --- OUTPUT FORMAT ---
  Registry_Set(
      0x4300,
      0x30); // FORMAT CONTROL 00: YUV422 (Bit 7:4=3), Order YUYV (Bit 3:0=0)
  Registry_Set(0x4301, 0x01); // FORMAT CONTROL 01: Data Sequence (Bit 1:0 = 01
                              // -> U/V from first pixel)
  Registry_Set(0x501F, 0x00); // FORMAT MUX CONTROL: Select ISP YUV422 (0x00)
  Registry_Set(0x4600, 0x80); // VFIFO CTRL00: JPEG Enable (Bit 5)? 0x80 usually
                              // implies a reset or specific block enable.

  // --- ISP & SCALING ---
  Registry_Set(0x5602, 0x40); // SCALE CTRL 2: X Scale High Byte? (Specifics
                              // depend on scaling algorithm used)
  Registry_Set(0x5604, 0x40); // SCALE CTRL 4: Y Scale High Byte?
  Registry_Set(
      0x5000,
      0x07); // ISP CONTROL 00: RAW Gamma (Bit 5), BPC (Bit 2), WPC (Bit 1), CIP
             // (Bit 0). 0x07 enables CIP, WPC, BPC. (Gamma OFF here?)

  // --- MANUAL COLOR & SATURATION ---
  Registry_Set(0x5180, 0x80); // AWB CONTROL: Manual Gain Enable (Bit 7=1)
  Registry_Set(0x5381, 0x20); // CMX1: Color Matrix Coefficient 1
  Registry_Set(0x5382, 0x64); // CMX2: Color Matrix Coefficient 2
  Registry_Set(0x5383, 0x08); // CMX3: Color Matrix Coefficient 3
  Registry_Set(0x5384, 0x30); // CMX4: Color Matrix Coefficient 4
  Registry_Set(0x5385, 0x90); // CMX5: Color Matrix Coefficient 5
  Registry_Set(0x5386, 0xC0); // CMX6: Color Matrix Coefficient 6
  Registry_Set(0x5387, 0xA0); // CMX7: Color Matrix Coefficient 7
  Registry_Set(0x5388, 0x98); // CMX8: Color Matrix Coefficient 8
  Registry_Set(0x5389, 0x08); // CMX9: Color Matrix Coefficient 9
  Registry_Set(0x538A, 0x01); // CMX SIGN: Signs for coefficients (High bits)
  Registry_Set(0x538B, 0x98); // CMX SIGN: Signs for coefficients (Low bits)

  // Manual Gains
  Registry_Set(0x3400, 0x04); // AWB MANUAL GAIN: Red Gain High Byte
  Registry_Set(0x3401, 0x00); // AWB MANUAL GAIN: Red Gain Low Byte
  Registry_Set(0x3402, 0x04); // AWB MANUAL GAIN: Green Gain High Byte
  Registry_Set(0x3403, 0x00); // AWB MANUAL GAIN: Green Gain Low Byte
  Registry_Set(0x3404, 0x04); // AWB MANUAL GAIN: Blue Gain High Byte
  Registry_Set(0x3405, 0x00); // AWB MANUAL GAIN: Blue Gain Low Byte
  Registry_Set(0x3406, 0x00); // AWB MANUAL GAIN: Common Gain?

  // Saturation
  Registry_Set(0x5580, 0x02); // SDE CTRL 0: SDE Enable (Bit 7)?
  Registry_Set(0x5583, 0x40); // SDE CTRL 3: Saturation U / Fixed U Value
  Registry_Set(0x5584, 0x40); // SDE CTRL 4: Saturation V / Fixed V Value
  Registry_Set(0x5587, 0x00); // SDE CTRL 7: Brightness (Y Bright)

  // Clipping (Limit YUV range)
  Registry_Set(0x4302, 0x03); // YMAX: Y Max Clip High
  Registry_Set(0x4304, 0x00); // YMIN: Y Min Clip High
  Registry_Set(0x4306, 0x03); // UMAX: U Max Clip High
  Registry_Set(0x4307, 0xFF); // UMAX: U Max Clip Low (1023)
  Registry_Set(0x4308, 0x00); // UMIN: U Min Clip High
  Registry_Set(0x4309, 0x00); // UMIN: U Min Clip Low (0)
  Registry_Set(0x430A, 0x03); // VMAX: V Max Clip High
  Registry_Set(0x430B, 0xFF); // VMAX: V Max Clip Low (1023)
  Registry_Set(0x430C, 0x00); // VMIN: V Min Clip High
  Registry_Set(0x430D, 0x00); // VMIN: V Min Clip Low (0)

  Registry_Set(0x5001, 0x27); // ISP CONTROL 01: SDE (Bit 7=0), Scale (Bit 5=1),
                              // UV Avg (Bit 2=1), CMX (Bit 1=1), AWB (Bit 0=1)
                              // -> 0010 0111 = 0x27? Check bits.
  Registry_Set(0x5000,
               0x25); // ISP CONTROL 00: RAW Gamma (Bit 5=1), BPC (Bit 2=1), WPC
                      // (Bit 1=0), CIP (Bit 0=1). 0x25 = 0010 0101.

  // Misc
  Registry_Set(0x4602, 0x01); // VFIFO HSIZE: High Byte (320?)
  Registry_Set(0x4603, 0x40); // VFIFO HSIZE: Low Byte
  Registry_Set(0x4604, 0x00); // VFIFO VSIZE: High Byte (240?)
  Registry_Set(0x4605, 0xF0); // VFIFO VSIZE: Low Byte
  Registry_Set(0x460C, 0x20); // VFIFO CTRL0C: Dummy Data Pad Speed / Threshold
  Registry_Set(0x460D, 0x00); // VFIFO CTRL0D: JPEG Pad Dummy Data

  // Timing / Sync
  Registry_Set(0x4709, 0x02); // DVP VSYNC WIDTH 0: VSYNC Width Line Unit
  Registry_Set(0x470A, 0x00); // DVP VSYNC WIDTH 1: VSYNC Width PCLK Unit High
  Registry_Set(0x470B, 0xFF); // DVP VSYNC WIDTH 2: VSYNC Width PCLK Unit Low
  Registry_Set(0x4711, 0x00); // PAD LEFT CTRL: Left Padding
  Registry_Set(0x4712, 0x00); // PAD RIGHT CTRL: Right Padding
  Registry_Set(0x4713, 0x02); // JPG MODE SELECT: JPEG Mode (Mode 2)
  Registry_Set(0x4715, 0x00); // 656 DUMMY LINE: CCIR656 Dummy Line Count
  Registry_Set(0x4719, 0x00); // CCIR656 CTRL: EAV/SAV Options
  Registry_Set(0x471B,
               0x02); // HSYNC CTRL 00: HSYNC Mode Enable (Bit 0=0?), Polarity?
  Registry_Set(0x471D, 0x01); // DVP VSYNC CTRL: VSYNC Polarity / Trigger Mode
  Registry_Set(0x471F,
               0x40); // DVP HREF CTRL: HREF Minimum Blanking (JPEG Mode)
  Registry_Set(0x4721, 0x00); // VERTICAL START OFFSET: VSYNC Delay
  Registry_Set(0x4723, 0x00); // DVP CTRL 23: JPEG Mode Skip Lines
  Registry_Set(0x503D,
               0x00); // PRE ISP TEST SETTING 1: Color Bar Disable (Bit 7=0)
  Registry_Set(0x4741, 0x00); // TEST PATTERN: DVP Test Pattern Disable
  Registry_Set(0x4740,
               0x23); // POLARITY CTRL 00: PCLK/HREF/VSYNC Polarity. 0x23 = 0010
                      // 0011 -> Gate PCLK (Bit 5=1?), HREF Active High (Bit
                      // 1=1), VSYNC Active High (Bit 0=1)
  Registry_Set(0x4745, 0x00); // DATA ORDER: DVP Output Bit Order (Normal)

  // Note: We do NOT put the "Stream Start" (0x3008=0x02/0x00) here usually,
  // because that should be the very last command after ApplyAll.

  defaults_loaded = true;
  printf("[REG] Defaults loaded into memory.\n");
}

/**
 * @brief Orchestrates the software-side initialization of the camera via I2C.
 *
 * Handles sensor reset, clock activation, and applying the registry contents.
 */
static void CameraI2Cinit(void) {
  // 1. HARDWARE RESET / POWER CYCLE
  // CamhardwareReset(); not required

  // 2. CRITICAL BOOT SEQUENCE (Software Reset & Clocks)
  // These require specific delays, so we keep them hardcoded OUTSIDE the
  // registry
  cam_write_u8(0x3008, 0x80); // Software reset
  HAL_Delay(5);
  cam_write_u8(0x3008, 0x00); // Normal operation
  HAL_Delay(5);
  cam_write_u8(0x3004, 0xFF); // Core clocks on
  cam_write_u8(0x3005, 0xFF); // ISP / AE / AWB clocks on
  cam_write_u8(0x3006, 0xFF); // PSRAM / JPEG / format clocks on
  cam_write_u8(0x3007, 0xFF); // DVP PCLK enable

  // 3. LOAD DATA
  // If this is the first boot, load the hardcoded defaults into the Registry.
  // If this is a subsequent "Reset", we keep the Registry as-is (preserving
  // USB updates).
  if (!defaults_loaded) {
    Registry_LoadDefaults();
  }

  // 4. APPLY REGISTRY
  Registry_ApplyAll();

  // 5. ENABLE STREAMING
  cam_write_u8(0x3008, 0x00); // Start Streaming
  printf("OV5640 init via Registry complete\n");
}

// Helper to convert hex string to int
uint32_t ParseHex(char *str) { return (uint32_t)strtol(str, NULL, 16); }

/**
 * @brief Decodes register update commands received via USB.
 *
 * Parses strings in the format "W <HEX_REG> <HEX_VAL>" and stores them
 * in the local registry for application.
 *
 * @param cmd The raw command string.
 */
void Parse_USB_Command(char *cmd) {
  // Format expected: "W <REG> <VAL>"  e.g., "W 3008 02"
  // cmd[0] is command char

  if (cmd[0] == 'W' || cmd[0] == 'w') // Write / Update
  {
    // strtok is destructive, but usb buffer is volatile anyway
    char *token = strtok(cmd, " "); // Get 'W'
    token = strtok(NULL, " ");      // Get Register (e.g. "3008")

    if (token != NULL) {
      uint16_t reg = (uint16_t)ParseHex(token);

      token = strtok(NULL, " "); // Get Value (e.g. "80")
      if (token != NULL) {
        uint8_t val = (uint8_t)ParseHex(token);

        // UPDATE THE COMMON VARIABLE (REGISTRY)
        Registry_Set(reg, val);

        printf("USB: Queued Reg 0x%04X = 0x%02X\n", reg, val);
      }
    }
  }
}

void DCMI_DumpAll(const char *label) {
  DCMI_TypeDef *d = DCMI; // or hdcmi.Instance

  printf("\n===== DCMI REG DUMP: %s =====\n", label ? label : "");
  printf("CR      = 0x%08lX\n", (uint32_t)d->CR);
  printf("SR      = 0x%08lX\n", (uint32_t)d->SR);
  printf("RISR    = 0x%08lX\n", (uint32_t)d->RISR);
  printf("IER     = 0x%08lX\n", (uint32_t)d->IER);
  printf("MISR    = 0x%08lX\n", (uint32_t)d->MISR);
  printf("ICR     = 0x%08lX\n", (uint32_t)d->ICR);
  printf("ESCR    = 0x%08lX\n", (uint32_t)d->ESCR);
  printf("ESUR    = 0x%08lX\n", (uint32_t)d->ESUR);
  printf("CWSTRTR = 0x%08lX\n", (uint32_t)d->CWSTRTR);
  printf("CWSIZER = 0x%08lX\n", (uint32_t)d->CWSIZER);
  printf("==============================\n");
}

/* Called on every line end if LINE IT enabled */
void HAL_DCMI_LineEventCallback(DCMI_HandleTypeDef *hdcmi) {
  printf("LINEEVENTCALLBACK");
  // printf("FNE=%lu\n", (uint32_t)((DCMI->SR & DCMI_SR_FNE) ? 1 : 0));
}

/* Called at frame end (VSYNC trailing edge when FRAME IT enabled) */
void HAL_DCMI_VsyncEventCallback(DCMI_HandleTypeDef *hdcmi) {
  printf("VSYNCEVENTCALLBACK\n");
}

void HAL_DCMI_FrameEventCallback(DCMI_HandleTypeDef *hdcmi_) {
  dcache_invalidate_fb();

  camera_frame_ready = 1;

  printf("frame recieved---\n");
}

/* FIFO/sync errors */
void HAL_DCMI_ErrorCallback(DCMI_HandleTypeDef *hdcmi) {
  camera_error_flag = 1;
  // Check using direct register access
  if (hdcmi->Instance->RISR & DCMI_RIS_OVR_RIS) {
    // Clear using direct register access
    hdcmi->Instance->ICR = DCMI_ICR_OVR_ISC;
  }
}

/**
 * @brief Fully initializes the camera system (GPIO, DCMI, I2C, and Sensor).
 */
static void Camerainit(void) {
  printf("Start cameraHardwareReset\n");
  CamhardwareReset();
  printf("Camera hardwarereset complete\n");

  HAL_Delay(100);

  printf("Start DCMI init\n");
  MX_DCMI_Init();
  printf("MX DCMI init complete\n");

  __HAL_DCMI_ENABLE_IT(&hdcmi, DCMI_IT_LINE | DCMI_IT_FRAME | DCMI_IT_VSYNC |
                                   DCMI_IT_ERR);

  printf("I2C init start\n");
  CameraI2Cinit();
  printf("I2C init complete\n");

  HAL_Delay(1000);
}

static inline void swo_hex_byte(uint8_t v) {
  static const char HEX[] = "0123456789ABCDEF";
  ITM_SendChar((uint32_t)HEX[v >> 4]);
  ITM_SendChar((uint32_t)HEX[v & 0xF]);
}

static void DumpImageData(uint32_t max_bytes) {
  uint32_t n = (max_bytes < FRAME_BYTES) ? max_bytes : FRAME_BYTES;

  printf("First %lu bytes from framebuf @ 0x%08lX:\n", (unsigned long)n,
         (unsigned long)FB_BASE_ADDR);

  for (uint32_t i = 0; i < n; i++) {
    if ((i % 16) == 0)
      printf("\n%6lu:", (unsigned long)i);
    printf(" %02X", framebuf[i]);
  }
  printf("\n\n");
}

void HAL_DMA_XferCpltCallback(DMA_HandleTypeDef *hdma) {
  if (hdma == &hdma_dcmi)
    printf("[DMA] TC (frame copied)\n");
}
void HAL_DMA_XferErrorCallback(DMA_HandleTypeDef *hdma) {
  if (hdma == &hdma_dcmi) {
    DMA_Stream_TypeDef *s = (DMA_Stream_TypeDef *)hdma->Instance;
    printf("[DMA] TE: CR=%08lX FCR=%08lX NDTR=%lu Error=0x%08lX\n",
           (uint32_t)s->CR, (uint32_t)s->FCR, (unsigned long)s->NDTR,
           (uint32_t)hdma->ErrorCode);
  }
}

/* --- Place this anywhere in main.c, after your includes and before main() ---
 */
/* --- VSYNC / FIFO monitor: no flag clears, no stop --- */
static void DCMI_SyncTest(uint32_t duration_ms) {
  printf("\n===== DCMI FIRST LINE DUMP =====\n");

  HAL_DCMI_Stop(&hdcmi);
  DCMI->ICR = 0x1F;

  SET_BIT(DCMI->CR, DCMI_CR_ENABLE);
  SET_BIT(DCMI->CR, DCMI_CR_CAPTURE);

  // Wait for frame start (VSYNC active area)
  uint32_t timeout = HAL_GetTick() + 100; // 100 ms timeout
  while ((HAL_GetTick() < timeout)) {
    uint32_t sr = DCMI->SR;
    int vsync = (sr & DCMI_SR_VSYNC) ? 1 : 0;
    int hsync = (sr & DCMI_SR_HSYNC) ? 1 : 0;
    int fne = (sr & DCMI_SR_FNE) ? 1 : 0;

    // Adjust vsync/hsync polarity to your config:
    if (/* inside active frame */ vsync == 0 && hsync == 1 && fne) {
      printf("Starting FIFO dump (vsync=%d, hsync=%d)\n", vsync, hsync);

      for (uint32_t i = 0; i < 128; i++) {
        if (!(DCMI->SR & DCMI_SR_FNE))
          break;

        uint32_t data = DCMI->DR;
        uint32_t sr_now = DCMI->SR;
        printf("%4lu: DR=0x%08lX  SR=0x%08lX\n", (unsigned long)i,
               (unsigned long)data, (unsigned long)sr_now);
      }

      break;
    }
  }

  CLEAR_BIT(DCMI->CR, DCMI_CR_CAPTURE);
  printf("===== END FIRST LINE DUMP =====\n\n");
}

static void ov5640_read_pads_raw(uint8_t *r50, uint8_t *r51, uint8_t *r52) {
  // use your existing cam_read_u8(reg, &val)
  cam_read_u8(0x3050, r50);
  cam_read_u8(0x3051, r51);
  cam_read_u8(0x3052, r52);
}

static void OV5640_PadMonitor(uint32_t duration_ms) {
  printf("\n===== OV5640 D[9:0] ACTIVITY + TOGGLE COUNTER =====\n");

  uint32_t start = HAL_GetTick();

  uint16_t seen_low = 0;
  uint16_t seen_high = 0;

  int last_state[10];
  int toggle_count[10] = {0};

  // Initialize last_state from first read
  {
    uint8_t r50, r51, r52;
    ov5640_read_pads_raw(&r50, &r51, &r52);

    last_state[9] = (r51 >> 3) & 1;
    last_state[8] = (r51 >> 2) & 1;
    last_state[7] = (r51 >> 1) & 1;
    last_state[6] = (r51 >> 0) & 1;

    last_state[5] = (r52 >> 7) & 1;
    last_state[4] = (r52 >> 6) & 1;
    last_state[3] = (r52 >> 5) & 1;
    last_state[2] = (r52 >> 4) & 1;
    last_state[1] = (r52 >> 3) & 1;
    last_state[0] = (r52 >> 2) & 1;

    // mark initial states
    for (int i = 0; i < 10; i++) {
      if (last_state[i] == 0)
        seen_low |= (1U << i);
      else
        seen_high |= (1U << i);
    }
  }

  while ((HAL_GetTick() - start) < duration_ms) {
    uint8_t r50, r51, r52;
    ov5640_read_pads_raw(&r50, &r51, &r52);

    int d[10];
    d[9] = (r51 >> 3) & 1;
    d[8] = (r51 >> 2) & 1;
    d[7] = (r51 >> 1) & 1;
    d[6] = (r51 >> 0) & 1;

    d[5] = (r52 >> 7) & 1;
    d[4] = (r52 >> 6) & 1;
    d[3] = (r52 >> 5) & 1;
    d[2] = (r52 >> 4) & 1;
    d[1] = (r52 >> 3) & 1;
    d[0] = (r52 >> 2) & 1;

    // update info
    for (int i = 0; i < 10; i++) {

      // count toggles
      if (d[i] != last_state[i]) {
        toggle_count[i]++;
        last_state[i] = d[i];
      }

      // track high/low presence
      if (d[i] == 0)
        seen_low |= (1U << i);
      else
        seen_high |= (1U << i);
    }

    HAL_Delay(1);
  }

  printf("===== RESULTS AFTER %lu ms =====\n", (unsigned long)duration_ms);

  for (int i = 0; i < 10; i++) {
    int lo = (seen_low & (1U << i)) != 0;
    int hi = (seen_high & (1U << i)) != 0;

    printf("D%d:  toggles=%d   ", i, toggle_count[i]);

    if (lo && hi)
      printf("PASS (0→1→0 activity)\n");
    else if (hi && !lo)
      printf("FAIL (stuck HIGH)\n");
    else if (lo && !hi)
      printf("FAIL (stuck LOW)\n");
    else
      printf("FAIL (no signal)\n");
  }

  printf("===== END CHECK =====\n\n");
}

/**
 * @brief Performs a single-shot image capture.
 *
 * Sanitizes the DCMI state, clears hardware flags (overruns), starts the DMA
 * transfer, and waits for either a successful frame completion or a timeout.
 */
void Camera_CaptureOneFrame(void) {
  printf("\n===== CAMERA: START CAPTURE =====\n");

  // --- STEP 1: SANITIZE (The Fix) ---
  // 1. Ensure the peripheral is STOPPED. If it was stuck in BUSY from a
  // previous error, this frees it.
  HAL_DCMI_Stop(&hdcmi);

  // 2. Disable Interrupts momentarily to prevent firing on old flags
  __HAL_DCMI_DISABLE_IT(&hdcmi, DCMI_IT_FRAME | DCMI_IT_OVR | DCMI_IT_ERR |
                                    DCMI_IT_VSYNC | DCMI_IT_LINE);

  // 3. NUKE ALL FLAGS. This is the most important line.
  // We likely have an OVR flag pending from the time we spent sending USB
  // data. We clear Frame, Overrun, Error, Vsync, and Line flags.
  hdcmi.Instance->ICR = DCMI_ICR_FRAME_ISC | DCMI_ICR_OVR_ISC |
                        DCMI_ICR_ERR_ISC | DCMI_ICR_VSYNC_ISC |
                        DCMI_ICR_LINE_ISC;

  // 4. Reset Logic Flags
  camera_frame_ready = 0;
  camera_error_flag = 0;

  // 5. Re-enable Interrupts
  __HAL_DCMI_ENABLE_IT(&hdcmi, DCMI_IT_FRAME | DCMI_IT_OVR | DCMI_IT_ERR);

  // --- STEP 2: START DMA ---
  // Because we called HAL_DCMI_Stop() above, the State is now
  // HAL_DCMI_STATE_READY.
  HAL_StatusTypeDef st =
      HAL_DCMI_Start_DMA(&hdcmi, DCMI_MODE_SNAPSHOT, (uint32_t)framebuf,
                         38400 // Size in words
      );

  if (st != HAL_OK) {
    printf("CRITICAL ERROR: DCMI Start failed: %d (State: %d)\n", st,
           hdcmi.State);
    return;
  }

  // --- STEP 3: WAIT FOR COMPLETION ---
  uint32_t t0 = HAL_GetTick();
  while (!camera_frame_ready && !camera_error_flag) {
    // Timeout (1s)
    if ((HAL_GetTick() - t0) > 1000) {
      printf("ERROR: Timeout waiting for Frame.\n");
      // If we timeout, we MUST stop to reset the state for the next try
      HAL_DCMI_Stop(&hdcmi);
      return;
    }
  }

  // --- STEP 4: CLEANUP ---
  // Whether success or error, we STOP the DCMI immediately.
  // This prevents the DCMI from detecting "Overruns" while we go off to send
  // USB data.
  HAL_DCMI_Stop(&hdcmi);

  if (camera_error_flag) {
    printf("FAILURE: Frame Error (Overrun or Hardware).\n");
  } else {
    printf("SUCCESS: Capture Complete.\n");
  }
}

void DumpFullFrame(void) {
  for (uint32_t i = 0; i < FRAME_BYTES; i++)
    printf("%02X", framebuf[i]);
}

/**
 * @brief Transmits the entire frame buffer to the host PC via USB CDC.
 *
 * Breaks the large frame buffer into smaller chunks to accommodate USB packet
 * limits and waits for the peripheral to become ready before each transmission.
 */
void DumpFullFrame_USB(void) {
  uint32_t remaining = FRAME_BYTES;
  uint32_t index = 0;
  uint8_t status;

  while (remaining > 0) {
    // Calculate size of the next packet to send
    uint16_t len = (remaining > CHUNK_SIZE) ? CHUNK_SIZE : remaining;

    // Wait until USB is free (USBD_BUSY means previous packet is still going)
    do {
      status = CDC_Transmit_HS(&framebuf[index], len);
    } while (status == USBD_BUSY);

    // If we hit an error, abort to prevent getting stuck
    if (status != USBD_OK)
      break;

    index += len;
    remaining -= len;
  }
}

void FullCapture(void) {
  Camera_CaptureOneFrame();

  // DumpFullFrame();

  DumpFullFrame_USB();
}
/* USER CODE END 0 */

/**
 * @brief  The application entry point.
 * @retval int
 */
int main(void) {
  /* USER CODE BEGIN 1 */
  /* USER CODE END 1 */

  /* MPU
   * Configuration--------------------------------------------------------*/

  MPU_Config();

  /* MCU
   * Configuration--------------------------------------------------------*/

  SCB_EnableICache();
  SCB_EnableDCache();

  /* Reset of all peripherals, Initializes the Flash interface and the
   * Systick.
   */
  HAL_Init();
  SystemClock_Config();
  MX_DMA_Init();
  MX_GPIO_Init();
  MX_I2C1_Init();
  MX_USB_DEVICE_Init();

  SWO_Init(2000000);

  printf("started\n");

  Camerainit();
  __HAL_DCMI_ENABLE_IT(&hdcmi, DCMI_IT_FRAME | DCMI_IT_LINE | DCMI_IT_OVR |
                                   DCMI_IT_ERR);
  HAL_Delay(200);

  /* USER CODE BEGIN WHILE */
  while (1) {
    if (usb_rx_flag == 1) {
      // 1. CLEAR FLAG IMMEDIATELY
      usb_rx_flag = 0;

      // 2. CREATE A LOCAL COPY
      char local_cmd[64];
      memcpy(local_cmd, (char *)usb_rx_buffer, 64);
      local_cmd[63] = '\0';

      printf("RX: %s\n", local_cmd);

      // 4. PARSE COMMANDS
      if (local_cmd[0] == 'S') {
        FullCapture();
      } else if (local_cmd[0] == 'L') { // <--- ADD THIS BLOCK
        // Enter the blocking Live Loop
        Camera_LiveLoop();
      } // <--- END ADDITION
      else if (local_cmd[0] == 'R') {
        Camera_Hard_Reset();
      } else if (local_cmd[0] == 'W' || local_cmd[0] == 'w') {
        // ... existing Write logic ...
        uint32_t reg_in, val_in;
        int items = sscanf(local_cmd + 1, "%x %x", (unsigned int *)&reg_in,
                           (unsigned int *)&val_in);

        if (items == 2) {
          printf("PARSED: Reg=0x%04X Val=0x%02X\n", (uint16_t)reg_in,
                 (uint8_t)val_in);
          Registry_Set((uint16_t)reg_in, (uint8_t)val_in);
        } else {
          printf("ERROR: Bad W format. Got %d items.\n", items);
        }
      }
    }
  }
  /* USER CODE END WHILE */
}

/**
 * @brief System Clock Configuration
 * @retval None
 */
void SystemClock_Config(void) {
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

  /** Supply configuration update enable
   */
  HAL_PWREx_ConfigSupply(PWR_LDO_SUPPLY);

  /** Configure the main internal regulator output voltage
   */
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE0);

  while (!__HAL_PWR_GET_FLAG(PWR_FLAG_VOSRDY)) {
  }

  /** Initializes the RCC Oscillators according to the specified parameters
   * in the RCC_OscInitTypeDef structure.
   */
  RCC_OscInitStruct.OscillatorType =
      RCC_OSCILLATORTYPE_CSI | RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.CSIState = RCC_CSI_ON;
  RCC_OscInitStruct.CSICalibrationValue = RCC_CSICALIBRATION_DEFAULT;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLM = 5;
  RCC_OscInitStruct.PLL.PLLN = 190;
  RCC_OscInitStruct.PLL.PLLP = 2;
  RCC_OscInitStruct.PLL.PLLQ = 5;
  RCC_OscInitStruct.PLL.PLLR = 2;
  RCC_OscInitStruct.PLL.PLLRGE = RCC_PLL1VCIRANGE_2;
  RCC_OscInitStruct.PLL.PLLVCOSEL = RCC_PLL1VCOWIDE;
  RCC_OscInitStruct.PLL.PLLFRACN = 0;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK) {
    Error_Handler();
  }

  /** Initializes the CPU, AHB and APB buses clocks
   */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK |
                                RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2 |
                                RCC_CLOCKTYPE_D3PCLK1 | RCC_CLOCKTYPE_D1PCLK1;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.SYSCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_HCLK_DIV2;
  RCC_ClkInitStruct.APB3CLKDivider = RCC_APB3_DIV2;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_APB1_DIV2;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_APB2_DIV2;
  RCC_ClkInitStruct.APB4CLKDivider = RCC_APB4_DIV2;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK) {
    Error_Handler();
  }
}

/**
 * @brief DCMI Initialization Function
 * @param None
 * @retval None
 */
static void MX_DCMI_Init(void) {
  /* USER CODE BEGIN DCMI_Init 0 */
  /* USER CODE END DCMI_Init 0 */

  /* USER CODE BEGIN DCMI_Init 1 */
  /* USER CODE END DCMI_Init 1 */
  hdcmi.Instance = DCMI;
  hdcmi.Init.SynchroMode = DCMI_SYNCHRO_HARDWARE;
  hdcmi.Init.PCKPolarity = DCMI_PCKPOLARITY_RISING;
  hdcmi.Init.VSPolarity = DCMI_VSPOLARITY_LOW;
  hdcmi.Init.HSPolarity = DCMI_HSPOLARITY_HIGH;
  hdcmi.Init.CaptureRate = DCMI_CR_ALL_FRAME;
  hdcmi.Init.ExtendedDataMode = DCMI_EXTEND_DATA_8B;
  hdcmi.Init.JPEGMode = DCMI_JPEG_DISABLE;
  hdcmi.Init.ByteSelectMode = DCMI_BSM_ALL;
  hdcmi.Init.ByteSelectStart = DCMI_OEBS_ODD;
  hdcmi.Init.LineSelectMode = DCMI_LSM_ALL;
  hdcmi.Init.LineSelectStart = DCMI_OELS_ODD;
  if (HAL_DCMI_Init(&hdcmi) != HAL_OK) {
    Error_Handler();
  }
  /* USER CODE BEGIN DCMI_Init 2 */
  /* USER CODE END DCMI_Init 2 */
}

/**
 * @brief I2C1 Initialization Function
 * @param None
 * @retval None
 */
static void MX_I2C1_Init(void) {
  /* USER CODE BEGIN I2C1_Init 0 */
  /* USER CODE END I2C1_Init 0 */

  /* USER CODE BEGIN I2C1_Init 1 */
  /* USER CODE END I2C1_Init 1 */
  hi2c1.Instance = I2C1;
  hi2c1.Init.Timing = 0x00000E14;
  hi2c1.Init.OwnAddress1 = 0;
  hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
  hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
  hi2c1.Init.OwnAddress2 = 0;
  hi2c1.Init.OwnAddress2Masks = I2C_OA2_NOMASK;
  hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
  hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
  if (HAL_I2C_Init(&hi2c1) != HAL_OK) {
    Error_Handler();
  }

  /** Configure Analogue filter
   */
  if (HAL_I2CEx_ConfigAnalogFilter(&hi2c1, I2C_ANALOGFILTER_ENABLE) != HAL_OK) {
    Error_Handler();
  }

  /** Configure Digital filter
   */
  if (HAL_I2CEx_ConfigDigitalFilter(&hi2c1, 0) != HAL_OK) {
    Error_Handler();
  }
  /* USER CODE BEGIN I2C1_Init 2 */
  /* USER CODE END I2C1_Init 2 */
}

/**
 * Enable DMA controller clock
 */
static void MX_DMA_Init(void) {
  /* DMA controller clock enable */
  __HAL_RCC_DMA1_CLK_ENABLE();

  /* DMA interrupt init */
  /* DMA1_Stream0_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA1_Stream0_IRQn, 0, 0);
  HAL_NVIC_EnableIRQ(DMA1_Stream0_IRQn);
}

/**
 * @brief GPIO Initialization Function
 * @param None
 * @retval None
 */
static void MX_GPIO_Init(void) {
  GPIO_InitTypeDef GPIO_InitStruct = {0};
  /* USER CODE BEGIN MX_GPIO_Init_1 */
  /* USER CODE END MX_GPIO_Init_1 */

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOE_CLK_ENABLE();
  __HAL_RCC_GPIOH_CLK_ENABLE();
  __HAL_RCC_GPIOC_CLK_ENABLE();
  __HAL_RCC_GPIOA_CLK_ENABLE();
  __HAL_RCC_GPIOB_CLK_ENABLE();
  __HAL_RCC_GPIOD_CLK_ENABLE();

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOD, CAM_RST_Pin | CAM_PWDN_Pin, GPIO_PIN_RESET);

  /*Configure GPIO pins : CAM_RST_Pin CAM_PWDN_Pin */
  GPIO_InitStruct.Pin = CAM_RST_Pin | CAM_PWDN_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);

  /* USER CODE BEGIN MX_GPIO_Init_2 */
  /* USER CODE END MX_GPIO_Init_2 */
}

/* USER CODE BEGIN 4 */
/**
 * @brief Performs a full system reset of both the hardware and peripheral
 * states.
 */
void Camera_Hard_Reset(void) {
  printf("--- STARTING HARD RESET ---\r\n");

  // 1. STOP DCMI & DMA
  // This halts any ongoing transfer and aborts the DMA stream
  HAL_DCMI_Stop(&hdcmi);

  // Optional: Explicitly De-Initialize DCMI to clear internal flags/states
  // HAL_DCMI_DeInit(&hdcmi);
  // MX_DCMI_Init(); // You must re-call the CubeMX generated init if you
  // DeInit

  Camerainit();
  // 4. FLUSH USB BUFFERS (Optional)
  // Ensure no junk data is sitting in the USB transmit buffer
  // CDC_Transmit_FS((uint8_t*)"READY", 5);

  printf("--- RESET COMPLETE ---\r\n");
}
/* USER CODE END 4 */

/* MPU Configuration */

void MPU_Config(void) {
  MPU_Region_InitTypeDef MPU_InitStruct = {0};

  /* Disables the MPU */
  HAL_MPU_Disable();

  /** Initializes and configures the Region and the memory to be protected
   */
  MPU_InitStruct.Enable = MPU_REGION_ENABLE;
  MPU_InitStruct.Number = MPU_REGION_NUMBER0;
  MPU_InitStruct.BaseAddress = 0x0;
  MPU_InitStruct.Size = MPU_REGION_SIZE_4GB;
  MPU_InitStruct.SubRegionDisable = 0x87;
  MPU_InitStruct.TypeExtField = MPU_TEX_LEVEL0;
  MPU_InitStruct.AccessPermission = MPU_REGION_NO_ACCESS;
  MPU_InitStruct.DisableExec = MPU_INSTRUCTION_ACCESS_DISABLE;
  MPU_InitStruct.IsShareable = MPU_ACCESS_SHAREABLE;
  MPU_InitStruct.IsCacheable = MPU_ACCESS_NOT_CACHEABLE;
  MPU_InitStruct.IsBufferable = MPU_ACCESS_NOT_BUFFERABLE;

  HAL_MPU_ConfigRegion(&MPU_InitStruct);
  /* Enables the MPU */
  HAL_MPU_Enable(MPU_PRIVILEGED_DEFAULT);

  /* Configure D2 SRAM (0x30000000) as Shareable/Non-Cacheable for USB DMA */
  MPU_InitStruct.Enable = MPU_REGION_ENABLE;
  MPU_InitStruct.Number = MPU_REGION_NUMBER1; // Use a different number than
                                              // your background region
  MPU_InitStruct.BaseAddress = 0x30000000;    // Address of RAM_D2
  MPU_InitStruct.Size =
      MPU_REGION_SIZE_32KB; // Or 256KB, depending on your linker
  MPU_InitStruct.SubRegionDisable = 0x0;
  MPU_InitStruct.TypeExtField = MPU_TEX_LEVEL0;
  MPU_InitStruct.AccessPermission = MPU_REGION_FULL_ACCESS;
  MPU_InitStruct.DisableExec = MPU_INSTRUCTION_ACCESS_ENABLE;
  MPU_InitStruct.IsShareable = MPU_ACCESS_SHAREABLE;
  MPU_InitStruct.IsCacheable = MPU_ACCESS_NOT_CACHEABLE; // <--- CRITICAL
  MPU_InitStruct.IsBufferable = MPU_ACCESS_BUFFERABLE;

  HAL_MPU_ConfigRegion(&MPU_InitStruct);
}

/**
 * @brief  This function is executed in case of error occurrence.
 * @retval None
 */
void Error_Handler(void) {
  /* USER CODE BEGIN Error_Handler_Debug */
  /* USER CODE END Error_Handler_Debug */
}
#ifdef USE_FULL_ASSERT
/**
 * @brief  Reports the name of the source file and the source line number
 *         where the assert_param error has occurred.
 * @param  file: pointer to the source file name
 * @param  line: assert_param error line source number
 * @retval None
 */
void assert_failed(uint8_t *file, uint32_t line) {
  /* USER CODE BEGIN 6 */
  /* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */

// all code written by me with minimal AI assistance, comments added using AI
// and verified by me
